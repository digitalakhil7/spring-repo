## Securing URLs using SecurityFilterChain and Authentication using JWT
Important classes:
1. CustomUserDetailsService
2. JwtUtil
3. JwtFilter
4. JwtAEP
5. SecurityConfig
## Flow
1. Register user using /register
2. Send username, password to /login and get token
3. Send token for every protected API call
## Code
### application.properties
```properties
#DataBaseConnection
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/akhildb
spring.datasource.username=root
spring.datasource.password=akhil

#ORMDetails
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update
```
### Entity class
```java
@Entity
@Table(name = "user")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserEntity {
	@Id
	private String username;
	private String password;
	private String role;
}
```
### Repo
```java
@Repository
public interface UserRepo extends JpaRepository<UserEntity, String> {

}
```
### CustomUserDetailsService
```java
@Service
public class CustomUserDetailsService implements UserDetailsService {
	
	@Autowired
	private UserRepo repo;

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		UserEntity user = repo.findById(username).orElseThrow
		(() -> new UsernameNotFoundException("user not found with username: "+username));
		return User.withUsername(user.getUsername())
				.password(user.getPassword())
				.roles(user.getRole())
				.build();
	}

}
```
### JwtUtil
```java
@Component
public class JwtUtil {
	
	private String secretKey = "alongandbigsecretkeytogeneratetokensinspringbootapp";
	
	public String generateToken(String username) throws KeyLengthException, JOSEException {
		JWSHeader header = new JWSHeader(JWSAlgorithm.HS256);
		
		JWTClaimsSet claims = new JWTClaimsSet.Builder()
				.jwtID("1234")
				.subject(username)
				.issuer("companyName")
				.issueTime(new Date(System.currentTimeMillis()))
				.expirationTime(new Date(System.currentTimeMillis() + TimeUnit.MINUTES.toMillis(15)))
				.build();
		
		SignedJWT signature = new SignedJWT(header, claims);
		
		signature.sign(new MACSigner(secretKey));
		
		return signature.serialize();
	}
	
	public boolean validateToken(String token) throws ParseException, JOSEException {
		SignedJWT signature = SignedJWT.parse(token);
		
		boolean isSignValid = signature.verify(new MACVerifier(secretKey));
		
		boolean tokenNotExpired = signature.getJWTClaimsSet().getExpirationTime().after(new Date(System.currentTimeMillis()));
		
		return isSignValid && tokenNotExpired;
	}
	
	public String getUsername(String token) throws ParseException {
		return SignedJWT.parse(token).getJWTClaimsSet().getSubject();
	}
}
```
### JwtFilter
```java
@Component
public class JwtFilter extends OncePerRequestFilter {
	
	@Autowired
	private JwtUtil jwtUtil;
	
	@Autowired
	private CustomUserDetailsService userDetailsService;

	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {
		
		//1. get username from header
		String header = request.getHeader("Authorization");
		
		String username = null;
		String token = null;
		
		if(header!=null && header.startsWith("Bearer ")) {
			token = header.substring(7);
			try {
				username = jwtUtil.getUsername(token);
			} catch (ParseException e) {
				e.printStackTrace();
			}
		}

		// 2. if user is not authenticated - load UserDetails from db and set authentication object in the SecurityContext
		if(username!=null && SecurityContextHolder.getContext().getAuthentication()==null) {
			UserDetails userDetails = userDetailsService.loadUserByUsername(username);
			UsernamePasswordAuthenticationToken authToken = 
					new UsernamePasswordAuthenticationToken(userDetails.getUsername(), null, userDetails.getAuthorities());
			SecurityContextHolder.getContext().setAuthentication(authToken);
		}
		
		filterChain.doFilter(request, response);

	}

}
```
### JwtAuthenticationEntryPoint
```java
@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint{

	@Override
	public void commence(HttpServletRequest request, HttpServletResponse response,
			AuthenticationException authException) throws IOException, ServletException {
		response.sendError(HttpServletResponse.SC_PAYMENT_REQUIRED, "Haha");
		
	}

}
```
### SecurityConfig
```java
import static org.springframework.security.config.Customizer.withDefaults;
@Configuration
public class SecurityConfig {
	
	@Autowired
	private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
	
	@Autowired
	private JwtFilter jwtFilter;
	
    @Bean
    SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) {
        http
        .csrf(csrf -> csrf.disable())
        .authorizeHttpRequests((requests) -> requests
                .requestMatchers("/home", "/about", "/register", "/login").permitAll()
                .anyRequest().authenticated()
        );
        http.exceptionHandling(exception -> exception.authenticationEntryPoint(jwtAuthenticationEntryPoint));
        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }
    
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
}
```
### RestController
```java
@RestController
public class MyController {
	
	@Autowired
	private UserRepo repo;
	
	@Autowired
	private PasswordEncoder encoder;
	
	@Autowired
	private AuthenticationManager authenticationManager;
	
	@Autowired
	private JwtUtil jwtUtil;
	
	// Unprotected APIs
	@PostMapping("/register")
	public ResponseEntity<String> registerUser(@RequestBody UserEntity user){
		user.setPassword(encoder.encode(user.getPassword()));
		repo.save(user);
		
		return new ResponseEntity<>("User registered", HttpStatus.CREATED);
	}
	
	// Generate Token if username and password are valid
	@PostMapping("/login")
	public ResponseEntity<String> login(@RequestBody UserEntity user) throws JOSEException{
		authenticationManager
		.authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword()));
		
		return new ResponseEntity<>(jwtUtil.generateToken(user.getUsername()), HttpStatus.CREATED);
	}
	
	@GetMapping("/home")
	public ResponseEntity<String> getHome() {
		return new ResponseEntity<String>("Home", HttpStatus.OK);
	}
	
	@GetMapping("/about")
	public ResponseEntity<String> getAbout() {
		return new ResponseEntity<String>("About", HttpStatus.OK);
	}
	
	// Protected APIs
	@GetMapping("/landing")
	public ResponseEntity<String> getLanding() {
		return new ResponseEntity<String>("Landing", HttpStatus.OK);
	}
	
	@GetMapping("/approve")
	public ResponseEntity<String> getApprove() {
		return new ResponseEntity<String>("Approve", HttpStatus.OK);
	}
	
}
```
